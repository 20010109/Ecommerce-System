package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"database/sql"
	"fmt"
	"paymentservice/graph/model"
	"time"

	_ "github.com/lib/pq"
)

// CreatePayment is the resolver for the createPayment field.
func (r *mutationResolver) CreatePayment(ctx context.Context, input model.NewPayment) (*model.Payment, error) {
	now := time.Now()
	var id int
	transactionRef := fmt.Sprintf("txn_%d", now.UnixNano())
	err := r.DB.QueryRowContext(ctx, `
        INSERT INTO payments (
            order_id, user_id, amount, currency,
            payment_method, payment_status, transaction_reference,
            payment_provider, paid_at, created_at, updated_at
        ) VALUES (
            $1, $2, $3, $4,
            $5, $6, $7,
            $8, $9, $10, $11
        ) RETURNING id
    `,
		input.OrderID,
		input.UserID,
		input.Amount,
		input.Currency,
		input.PaymentMethod,
		"pending",
		transactionRef,
		input.PaymentProvider,
		nil,
		now,
		now,
	).Scan(&id)

	if err != nil {
		return nil, fmt.Errorf("insert failed: %v", err)
	}

	return &model.Payment{
		ID:                   fmt.Sprintf("%d", id),
		OrderID:              input.OrderID,
		UserID:               input.UserID,
		Amount:               input.Amount,
		Currency:             input.Currency,
		PaymentMethod:        input.PaymentMethod,
		PaymentStatus:        "pending",
		TransactionReference: &transactionRef,
		PaymentProvider:      input.PaymentProvider,
		CreatedAt:            (*model.Time)(&now),
		UpdatedAt:            (*model.Time)(&now),
	}, nil
}

// Payments is the resolver for the payments field.
func (r *queryResolver) Payments(ctx context.Context) ([]*model.Payment, error) {
	rows, err := r.DB.QueryContext(ctx, `
        SELECT id, order_id, user_id, amount, currency,
               payment_method, payment_status, transaction_reference,
               payment_provider, paid_at, created_at, updated_at
        FROM payments
    `)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var payments []*model.Payment

	for rows.Next() {
		var p model.Payment
		var paidAt, createdAt, updatedAt sql.NullTime
		var transactionRef sql.NullString
		var paymentProvider sql.NullString

		err := rows.Scan(
			&p.ID, &p.OrderID, &p.UserID, &p.Amount, &p.Currency,
			&p.PaymentMethod, &p.PaymentStatus, &transactionRef,
			&paymentProvider, &paidAt, &createdAt, &updatedAt,
		)
		if err != nil {
			return nil, err
		}

		if transactionRef.Valid {
			p.TransactionReference = &transactionRef.String
		}
		if paymentProvider.Valid {
			p.PaymentProvider = &paymentProvider.String
		}
		if paidAt.Valid {
			t := model.Time(paidAt.Time)
			p.PaidAt = &t
		}
		if createdAt.Valid {
			t := model.Time(createdAt.Time)
			p.CreatedAt = &t
		}
		if updatedAt.Valid {
			t := model.Time(updatedAt.Time)
			p.UpdatedAt = &t
		}

		payments = append(payments, &p)
	}
	return payments, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
