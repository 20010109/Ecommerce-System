package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"PaymentService/graph/queue"
	"PaymentService/graph/model"
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"strconv"
	"time"
	"strings"
)

// CreatePayment is the resolver for the createPayment field.
func (r *mutationResolver) CreatePayment(ctx context.Context, input model.NewPayment) (*model.Payment, error) {
	now := time.Now()
	transactionRef := fmt.Sprintf("txn_%d", now.UnixNano())
	var id int

	err := r.DB.QueryRowContext(ctx, `
		INSERT INTO payments (
			order_id, user_id, amount, currency,
			payment_method, payment_status, transaction_reference,
			payment_provider, paid_at, created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
		RETURNING id
	`,
		input.OrderID, input.UserID, input.Amount, input.Currency,
		input.PaymentMethod, "pending", transactionRef,
		input.PaymentProvider, nil, now, now,
	).Scan(&id)

	if err != nil {
		return nil, fmt.Errorf("insert failed: %v", err)
	}

	_, _ = r.DB.ExecContext(ctx, `
		INSERT INTO payment_logs (payment_id, status, message)
		VALUES ($1, 'pending', 'Payment created and pending verification')
	`, id)

	return &model.Payment{
		ID:                   id,
		OrderID:              input.OrderID,
		UserID:               input.UserID,
		Amount:               input.Amount,
		Currency:             input.Currency,
		PaymentMethod:        input.PaymentMethod,
		PaymentStatus:        "pending",
		TransactionReference: transactionRef,
		PaymentProvider:      input.PaymentProvider,
		CreatedAt:            &now,
		UpdatedAt:            &now,
	}, nil
}

// VerifyPayment is the resolver for the verifyPayment field.
func (r *mutationResolver) VerifyPayment(ctx context.Context, paymentID string) (*model.Payment, error) {
	now := time.Now()
	id, err := strconv.Atoi(paymentID)
	if err != nil {
		return nil, fmt.Errorf("invalid payment ID: %v", err)
	}

	_, err = r.DB.ExecContext(ctx, `
		UPDATE payments SET payment_status = 'completed', paid_at = $1, updated_at = $1
		WHERE id = $2
	`, now, id)
	if err != nil {
		return nil, fmt.Errorf("update failed: %v", err)
	}

	_, _ = r.DB.ExecContext(ctx, `
		INSERT INTO payment_logs (payment_id, status, message)
		VALUES ($1, 'completed', 'Payment marked as completed')
	`, id)

	return r.getPaymentByID(ctx, id)
}

// RefundPayment is the resolver for the refundPayment field.
func (r *mutationResolver) RefundPayment(ctx context.Context, paymentID string) (*model.Payment, error) {
	now := time.Now()
	id, err := strconv.Atoi(paymentID)
	if err != nil {
		return nil, fmt.Errorf("invalid payment ID: %v", err)
	}

	_, err = r.DB.ExecContext(ctx, `
		UPDATE payments SET payment_status = 'refunded', updated_at = $1
		WHERE id = $2
	`, now, id)
	if err != nil {
		return nil, fmt.Errorf("refund failed: %v", err)
	}

	_, _ = r.DB.ExecContext(ctx, `
		INSERT INTO payment_logs (payment_id, status, message)
		VALUES ($1, 'refunded', 'Payment refunded')
	`, id)

	return r.getPaymentByID(ctx, id)
}

// VerifyOnlinePayment is the resolver for the verifyOnlinePayment field.
func (r *mutationResolver) VerifyOnlinePayment(ctx context.Context, input model.VerifyPaymentInput) (*model.Payment, error) {
	var p model.Payment

	const maxRetries = 5
	const retryDelay = 300 * time.Millisecond

	var err error
	for attempt := 1; attempt <= maxRetries; attempt++ {
		row := r.DB.QueryRow(`
			SELECT id, order_id, user_id, amount, currency, payment_status 
			FROM payments 
			WHERE order_id = $1`, input.PaymentID)

		err = row.Scan(&p.ID, &p.OrderID, &p.UserID, &p.Amount, &p.Currency, &p.PaymentStatus)
		if err == nil {
			break
		}
		if err == sql.ErrNoRows {
			log.Printf("⏳ Retry %d: payment not found for order ID %d", attempt, input.PaymentID)
			time.Sleep(retryDelay)
		} else {
			log.Printf("❌ DB error: %v", err)
			return nil, err
		}
	}

	if err != nil {
		return nil, fmt.Errorf("payment for order ID %d not found after retries", input.PaymentID)
	}

	switch input.PaymentProvider {
	case "GCash":
		var data struct {
			Number string `json:"number"`
			Pin    string `json:"pin"`
		}
		if err := json.Unmarshal([]byte(input.Credentials), &data); err != nil || data.Number != "09171234567" || data.Pin != "1234" {
			r.DB.Exec(`INSERT INTO payment_logs (payment_id, status, message) VALUES ($1, 'failed', 'Invalid GCash credentials')`, p.ID)
			return nil, errors.New("invalid payment credentials")
		}
	case "PayMaya":
		var data struct {
			Email string `json:"email"`
			OTP   string `json:"otp"`
		}
		if err := json.Unmarshal([]byte(input.Credentials), &data); err != nil || data.Email != "test@paymaya.com" || data.OTP != "000111" {
			r.DB.Exec(`INSERT INTO payment_logs (payment_id, status, message) VALUES ($1, 'failed', 'Invalid PayMaya credentials')`, p.ID)
			return nil, errors.New("invalid payment credentials")
		}
	case "CreditCard":
		var data struct {
			Card   string `json:"card"`
			Expiry string `json:"expiry"`
			CVV    string `json:"cvv"`
		}
		if err := json.Unmarshal([]byte(input.Credentials), &data); err != nil || data.Card != "4111111111111111" || data.Expiry != "12/25" || data.CVV != "123" {
			r.DB.Exec(`INSERT INTO payment_logs (payment_id, status, message) VALUES ($1, 'failed', 'Invalid Credit Card credentials')`, p.ID)
			return nil, errors.New("invalid payment credentials")
		}
	default:
		return nil, errors.New("unsupported payment provider")
	}

	now := time.Now()
	_, err = r.DB.ExecContext(ctx,
		`UPDATE payments SET payment_status = $1, paid_at = $2, updated_at = $2, payment_provider = $3 WHERE id = $4`,
		"paid", now, input.PaymentProvider, p.ID)
	if err != nil {
		return nil, err
	}

	_, _ = r.DB.Exec(`INSERT INTO payment_logs (payment_id, status, message) VALUES ($1, 'paid', 'Online payment verified')`, p.ID)
	p.PaymentStatus = "paid"
	p.PaidAt = &now
	p.PaymentProvider = &input.PaymentProvider
	p.UpdatedAt = &now

	log.Printf("✅ Verified payment for order ID %d", input.PaymentID)
	return &p, nil
}

// Payments is the resolver for the payments field.
func (r *queryResolver) Payments(ctx context.Context) ([]*model.Payment, error) {
	rows, err := r.DB.QueryContext(ctx, `
		SELECT id, order_id, user_id, amount, currency,
		       payment_method, payment_status, transaction_reference,
		       payment_provider, paid_at, created_at, updated_at
		FROM payments
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var payments []*model.Payment

	for rows.Next() {
		var p model.Payment
		var paidAt, createdAt, updatedAt sql.NullTime
		var ref, provider sql.NullString

		err := rows.Scan(
			&p.ID, &p.OrderID, &p.UserID, &p.Amount, &p.Currency,
			&p.PaymentMethod, &p.PaymentStatus, &ref,
			&provider, &paidAt, &createdAt, &updatedAt,
		)
		if err != nil {
			return nil, err
		}

		if ref.Valid {
			p.TransactionReference = ref.String
		}
		if provider.Valid {
			p.PaymentProvider = &provider.String
		}
		if paidAt.Valid {
			p.PaidAt = &paidAt.Time
		}
		if createdAt.Valid {
			p.CreatedAt = &createdAt.Time
		}
		if updatedAt.Valid {
			p.UpdatedAt = &updatedAt.Time
		}

		payments = append(payments, &p)
	}

	return payments, nil
}

// GetPaymentByOrderID is the resolver for the getPaymentByOrderID field.
func (r *queryResolver) GetPaymentByOrderID(ctx context.Context, orderID int) (*model.Payment, error) {
	row := r.DB.QueryRow(`
		SELECT id, order_id, user_id, amount, currency,
			payment_method, payment_status, transaction_reference,
			payment_provider, paid_at
		FROM payments
		WHERE order_id = $1
	`, orderID)


	var p model.Payment
	var paidAt sql.NullTime
	var ref, provider sql.NullString
	
	err := row.Scan(
		&p.ID, &p.OrderID, &p.UserID, &p.Amount, &p.Currency,
		&p.PaymentMethod, &p.PaymentStatus, &ref,
		&provider, &paidAt,
	)	
	if err != nil {
		return nil, fmt.Errorf("payment not found: %v", err)
	}

	if ref.Valid {
		p.TransactionReference = ref.String
	}
	if provider.Valid {
		p.PaymentProvider = &provider.String
	}
	if paidAt.Valid {
		p.PaidAt = &paidAt.Time
	}
	

	return &p, nil
}

func (r *mutationResolver) getPaymentByID(ctx context.Context, id int) (*model.Payment, error) {
	row := r.DB.QueryRow(`
		SELECT id, order_id, user_id, amount, currency,
		       payment_method, payment_status, transaction_reference,
		       payment_provider, paid_at, created_at, updated_at
		FROM payments WHERE id = $1
	`, id)

	var p model.Payment
	var paidAt, createdAt, updatedAt sql.NullTime
	var ref, provider sql.NullString

	err := row.Scan(
		&p.ID, &p.OrderID, &p.UserID, &p.Amount, &p.Currency,
		&p.PaymentMethod, &p.PaymentStatus, &ref,
		&provider, &paidAt, &createdAt, &updatedAt,
	)
	if err != nil {
		return nil, err
	}

	if ref.Valid {
		p.TransactionReference = ref.String
	}
	if provider.Valid {
		p.PaymentProvider = &provider.String
	}
	if paidAt.Valid {
		p.PaidAt = &paidAt.Time
	}
	if createdAt.Valid {
		p.CreatedAt = &createdAt.Time
	}
	if updatedAt.Valid {
		p.UpdatedAt = &updatedAt.Time
	}

	return &p, nil
}

func (r *Resolver) CreatePaymentFromQueue(ctx context.Context, input queue.NewPayment) error {

	method := strings.ToUpper(input.PaymentMethod)
	timestamp := time.Now().UnixNano()
	transactionReference := fmt.Sprintf("TXN-%s-%d", method, timestamp)

	_, err := r.DB.ExecContext(ctx, `
		INSERT INTO payments (
			order_id, user_id, amount, currency,
			payment_method, payment_status, paid_at,
			payment_provider, transaction_reference
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
		ON CONFLICT (order_id) DO UPDATE SET
			payment_status = EXCLUDED.payment_status,
			paid_at = EXCLUDED.paid_at,
			payment_provider = COALESCE(EXCLUDED.payment_provider, payments.payment_provider),
			transaction_reference = COALESCE(EXCLUDED.transaction_reference, payments.transaction_reference)
		`,
		input.OrderID,
		input.UserID,
		input.Amount,
		input.Currency,
		input.PaymentMethod,
		input.PaymentStatus,
		input.PaidAt,
		input.PaymentProvider,
		transactionReference,
	)

	if err != nil {
		return fmt.Errorf("❌ Failed to insert payment: %w", err)
	}

	return nil
}


// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }



	
